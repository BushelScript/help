(self.webpackChunk=self.webpackChunk||[]).push([[614],{3905:(e,n,r)=>{"use strict";r.d(n,{Zo:()=>m,kt:()=>d});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function a(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var p=t.createContext({}),l=function(e){var n=t.useContext(p),r=n;return e&&(r="function"==typeof e?e(n):a(a({},n),e)),r},m=function(e){var n=l(e.components);return t.createElement(p.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=l(r),d=i,f=u["".concat(p,".").concat(d)]||u[d]||c[d]||o;return r?t.createElement(f,a(a({ref:n},m),{},{components:r})):t.createElement(f,a({ref:n},m))}));function d(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=u;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var l=2;l<o;l++)a[l]=r[l];return t.createElement.apply(null,a)}return t.createElement.apply(null,r)}u.displayName="MDXCreateElement"},5438:(e,n,r)=>{"use strict";r.r(n),r.d(n,{frontMatter:()=>s,metadata:()=>p,toc:()=>l,default:()=>c});var t=r(2122),i=r(9756),o=(r(7294),r(3905)),a=["components"],s={title:"B: Grammar",sidebar_label:"B: Grammar"},p={unversionedId:"ref/grammar",id:"ref/grammar",isDocsHomePage:!1,title:"B: Grammar",description:"The following is a compilation of all the Syntax sections throughout this reference, alongside some more fundamental definitions. Informal notions are defined with (parentheses). Please note that this is not a complete formal specification, and devising one is not a goal at the moment.",source:"@site/docs/ref/grammar.md",sourceDirName:"ref",slug:"/ref/grammar",permalink:"/help/docs/ref/grammar",version:"current",lastUpdatedBy:"Ian Gregory",lastUpdatedAt:1623393694,formattedLastUpdatedAt:"6/11/2021",sidebar_label:"B: Grammar",frontMatter:{title:"B: Grammar",sidebar_label:"B: Grammar"},sidebar:"ref",previous:{title:"A: Built-in Terms",permalink:"/help/docs/ref/built-in-terms"}},l=[],m={toc:l};function c(e){var n=e.components,r=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The following is a compilation of all the ",(0,o.kt)("strong",{parentName:"p"},"Syntax")," sections throughout this reference, alongside some more fundamental definitions. Informal notions are defined with ",(0,o.kt)("inlineCode",{parentName:"p"},"(parentheses)"),". Please note that this is ",(0,o.kt)("em",{parentName:"p"},"not")," a complete formal specification, and devising one is not a goal at the moment."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"# To simplify this grammar, we allow rules to be templates.\n# We write rule R templated on X as R( X ).\n# Here are some generally applicable templates we'll use:\n<pump>( R ) :: R [ <pump>( R ) ]\n<pump-with-end>( R, E ) <pump>( E | R )\n<delimited-list>( R, D ) :: R [ <pump>( D R ) ]\n<delimited-list-with-end>( R, D, E ) :: R ( E | <pump-with-end>( D R, E ) )\n\n# Fundamental notions:\n<utf-8>( E ) :: (any UTF-8 string that does not match rule E) E\n<category>( X1, \u2026, Xn, [ NOT E ] ) ::\n  (any UTF-8 grapheme cluster in Unicode General Category X1, or \u2026, or Xn\n   that does not match rule E, if given)\n<space> :: <category>(Z* NOT <line-break>)\n<line-break> ::\n  (one of:\n    U+000D U+000A (CRLF), U+000A thru U+000D,\n    U+0085, U+2028, or U+2029\n  )\n<digits> :: (any sequence of decimal digits 0 thru 9)\n\n<sequence-delimiter> :: <line-break> [ <pump>( <line-break> | <line-comment> ) ]\n<line-comment> :: '--' <utf-8>( <line-break> )\n\n# <blank> applies zero/one (depending on context) or more times\n# between all syntax elements:\n<blank> :: <space> | <block-comment>\n<block-comment> :: '--(' <utf-8>( ')--' )\n\n<term-name> :: delimited-list( <word>, <blank> )\n<term-name>( E ) :: <delimited-list-with-end>( <word>, <blank>, E )\n<lazy-term-name> :: <word> | ( '|' <term-name>( '|' ) )\n<word> :: <utf-8>( <space> | <category>( P*, S* NOT (one of _.-/'\u2019?) ) )\n\n<term-role> :: type | property | constant | command | parameter | variable | resource\n<term-uri>( E ) ::\n  id:<utf-8>( E ) |\n  res:(resource type):<utf-8>( E ) |\n  ae4:(4 characters) | ae8:(8 characters) | ae12:(12 characters) |\n  asid:<utf-8>\n\n<raw-term> :: '\xab' <term-role> <space> <term-uri>( '\xbb' )\n<term>( R ) :: <raw-term>(with role R) | (any term in the current lexicon with role R)\n<term> :: <term>(any role in <term-role>)\n<property> ::  <term>(property)\n<constant> ::  <term>(constant)\n<command> ::  <term>(command)\n<parameter> ::  <term>(parameter)\n<variable> ::  <term>(variable)\n<resource> ::  <term>(resource)\n\n<program> :: [ <delimited-list>( <expression>, <sequence-delimiter> ) ]\n<sequence>( E ) :: <delimited-list-with-end>( <expression>, <sequence-delimiter>, E )\n<sequence> :: <sequence>( end )\n<expression> ::\n  <definition> |\n  <group> |\n  <literal> |\n  <reference> |\n  <get-set> |\n  <control> |\n  <invocation> |\n  <compound> |\n  <require> |\n  <specifier>\n\n<definition> ::\n  <term-definition> | <variable-definition> | <function-definition>\n<term-definition> ::\n  define <term-name> [ as <term> ] |\n  defining <term-name> [ as <term> ] <sequence>\n<variable-definition> :: let ( <term-name>( be ) <expression> | <term-name> )\n<function-defintion> ::\n  on ( <term-name>( ':' ) <delimited-list>( <parameter-spec>, ',' ) | <term-name> )\n  <sequence>\n<parameter-spec> ::\n  <lazy-term-name> [ <term-name>( '(' ) <expression> ')' | <term-name> ]\n\n<group> ::\n  <grouped-expression> | <list> | <record>\n<grouped-expression> :: '(' <expression> ')'\n<list> :: '{' <delimited-list>( <expression>, ',' ) '}'\n<record> :: '{' <delimited-list>( <record-item>, ',' ) '}'\n<record-item> :: <expression> : <expression>\n\n<literal> ::\n  <integer> | <real> |\n  <string> | <multiline-string> | <interpreted-string> |\n  <boolean> | <null>\n<integer> :: <digits>(such that their value in base-10 is in [-2^63,2^63))\n<real> :: [ <digits> ] . <digits> [ ( e | E ) [ + | - ] <digits> ]\n<string> ::\n  ( ( \" <utf-8>( \" | <line-break> ) \" ) | ( \u201c <utf-8>( \u201d | <line-break> ) \u201d ) )\n<multiline-string> ::\n  ## <line-break> <utf-8>( ## ) |\n  ##(' <utf-8>( ')' ) <utf-8>( '##(' (same delimiter) ')' )\n<interpreted-string> :: #! <utf-8>( <line-break> ) <utf-8>( <interpreted-string> | #! )\n<boolean> :: true | false\n<null> :: null\n\n<reference> ::\n  <last-result> | <current-target> | <variable>\n<last-result> :: that\n<current-target> :: it\n\n<get-set> ::\n  <get> | <set>\n<get> :: get <expression>\n<set> :: set <expression> to <expression>\n\n<control> ::\n  <return> | <raise>\n<return> :: return <expression>\n<raise> :: raise <expression>\n\n<invocation> ::\n  <command> [ <expression> ] [ <pump>( <parameter> <expression> ) ] |\n  <unary-prefix-operator> <expression> |\n  <expression> <binary-infix-operator> <expression>\n<unary-prefix-operator> ::\n  (one of the operators in the table at Part 2 \xa7 Unary Prefix Operators)\n<binary-infix-operator> ::\n  (one of the operators in the table at Part 2 \xa7 Binary Infix Operators)\n\n<compound> ::\n  <conditional> | <conditional-loop> | <bounded-loop> | <iterative-loop> |\n  <error-handler> |\n  <with-module> | <with-target> |\n  <anonymous-function>\n<conditional> ::\n  if <expression> (\n    then <expression> [ else ( <expression> | <sequence> ) ] |\n    [ then ] <sequence> |\n    [ then ] <sequence>( else ) ( <expression> | <sequence> )\n  )\n<conditional-loop> :: repeat while <expression> <sequence>\n<bounded-loop> :: repeat <expression> times <sequence>\n<iterative-loop> :: repeat for <term-name> in <expression> <sequence>\n<error-handler> ::\n  try ( <expression> handle | <sequence>( handle ) ) ( <expression> | <sequence> )\n<with-module> :: tell <expression> ( to <expression> | <sequence> )\n<with-target> :: target <expression> ( then <expression> | <sequence> )\n<anonymous-function> ::\n  ( take <pump-with-end>( <term-name>( ',' ), <term-name>( do ) ) | do ) <sequence>\n\n<require> ::\n  <require-library> | <require-system> | <require-app> | <require-applescript>\n<require-library> :: use library <term-name>\n<require-system> :: use system [ version ( v | V ) <digits> . <digits> [ . <digits> ] ]\n<require-app> :: use app [ id ] <term-name>\n<require-applescript> :: AppleScript <term-name> at <string>\n\n<specifier> :: ( <element-specifier> | <property> ) [ of <expression> ]\n<element-specifier> ::\n  ( <simple-specifier> | <name-specifier> | <index-specifier> |\n    <id-specifier> |\n    <absolute-positioning-specifier> |\n    <relative-positioning-specifier> |\n    <all-specifier> |\n    <range-specifier> | <filter-specifier>\n  )\n<simple-specifier> :: <type> <expression>\n<name-specifier> :: <type> named <expression>\n<index-specifier> :: <type> index <expression>\n<id-specifier> :: <type> id <expression>\n<absolute-positioning-specifier> ::  first | middle | last | some ) <type>\n<relative-positioning-specifier> :: <type> ( before | after ) <expression>\n<all-specifier> :: ( all | every ) <type>\n<range-specifier> :: <type> <expression> ( thru | through ) <expression>\n<filter-specifier> :: <type> ( where | whose ) <expression>\n")))}c.isMDXComponent=!0}}]);