(self.webpackChunk=self.webpackChunk||[]).push([[914],{3905:(e,t,a)=>{"use strict";a.d(t,{Zo:()=>s,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var m=n.createContext({}),o=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},s=function(e){var t=o(e.components);return n.createElement(m.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),c=o(a),u=r,k=c["".concat(m,".").concat(u)]||c[u]||d[u]||i;return a?n.createElement(k,l(l({ref:t},s),{},{components:a})):n.createElement(k,l({ref:t},s))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=c;var p={};for(var m in t)hasOwnProperty.call(t,m)&&(p[m]=t[m]);p.originalType=e,p.mdxType="string"==typeof e?e:r,l[1]=p;for(var o=2;o<i;o++)l[o]=a[o];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},5825:(e,t,a)=>{"use strict";a.r(t),a.d(t,{frontMatter:()=>p,metadata:()=>m,toc:()=>o,default:()=>d});var n=a(2122),r=a(9756),i=(a(7294),a(3905)),l=["components"],p={title:"2-1: Terms",sidebar_label:"Part 1: Terms"},m={unversionedId:"ref/terms",id:"ref/terms",isDocsHomePage:!1,title:"2-1: Terms",description:"Terms are the syntactic particles of any BushelScript program. Each has a name, which identifies it in its dictionary, a type, which determines its syntactic function, and a UID, which uniquely identifies its runtime semantics.",source:"@site/docs/ref/terms.md",sourceDirName:"ref",slug:"/ref/terms",permalink:"/help/docs/ref/terms",version:"current",lastUpdatedBy:"Ian Gregory",lastUpdatedAt:1623393694,formattedLastUpdatedAt:"6/11/2021",sidebar_label:"Part 1: Terms",frontMatter:{title:"2-1: Terms",sidebar_label:"Part 1: Terms"},sidebar:"ref",previous:{title:"1-4: Object Types",permalink:"/help/docs/ref/object-types"},next:{title:"2-2: Dictionaries",permalink:"/help/docs/ref/dictionaries"}},o=[{value:"Term names",id:"term-names",children:[{value:"Normalization",id:"normalization",children:[]}]},{value:"Term types",id:"term-types",children:[]},{value:"Term UIDs",id:"term-uids",children:[{value:"UID domains",id:"uid-domains",children:[]}]},{value:"Typed UIDs (TUIDs)",id:"typed-uids-tuids",children:[]},{value:"Overlapping terms",id:"overlapping-terms",children:[{value:"Synonyms",id:"synonyms",children:[]},{value:"Homonyms",id:"homonyms",children:[]},{value:"Identical terms",id:"identical-terms",children:[]}]},{value:"Raw form",id:"raw-form",children:[]}],s={toc:o};function d(e){var t=e.components,a=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Terms")," are the syntactic particles of any BushelScript program. Each has a name, which identifies it in its ",(0,i.kt)("a",{parentName:"p",href:"dictionaries"},"dictionary"),", a type, which determines its syntactic function, and a UID, which uniquely identifies its runtime semantics."),(0,i.kt)("p",null,"See also: ",(0,i.kt)("a",{parentName:"p",href:"../tutorial/terms"},"Quick Tutorial"),"."),(0,i.kt)("h2",{id:"term-names"},"Term names"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"term name")," consists of one or more ",(0,i.kt)("em",{parentName:"p"},"words")," separated by whitespace and other ",(0,i.kt)("em",{parentName:"p"},"word-breaking characters"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<term-name> :: <word> [ <term-name> ]\n\n<word> :: (any valid UTF-8 byte sequence,\n           terminated by one of the following characters:\n             - Whitespace (Unicode General Category Z*, U+000A ~ U+000D, and U+0085)\n             - Punctuation (Unicode General Category P*)\n             - Symbols (Unicode General Category S*)\n             not including: _ . - / ' \u2019\n          )\n")),(0,i.kt)("h3",{id:"normalization"},"Normalization"),(0,i.kt)("p",null,"Term names are automatically ",(0,i.kt)("em",{parentName:"p"},"normalized")," by the parser. Normalization removes leading and trailing whitespace, and replaces any whitespace between words with a single space character."),(0,i.kt)("p",null,"For example, the parser normalizes both ",(0,i.kt)("code",null,"\xa0"," hello","\t","world","\xa0")," and ",(0,i.kt)("code",null,"hello","\t","\xa0","\t","world","\xa0","\t","\xa0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"hello world"),"."),(0,i.kt)("h2",{id:"term-types"},"Term types"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Term type"),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"define")," syntax"),(0,i.kt)("th",{parentName:"tr",align:null},"Syntactic function"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Dictionary"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"dictionary")),(0,i.kt)("td",{parentName:"tr",align:null},"Exists exclusively to contain a ",(0,i.kt)("a",{parentName:"td",href:"dictionaries"},"dictionary")," for organizational purposes.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Type"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"type")),(0,i.kt)("td",{parentName:"tr",align:null},"Can create a ",(0,i.kt)("inlineCode",{parentName:"td"},"type")," object or a variety of ",(0,i.kt)("a",{parentName:"td",href:"specifiers#element-specifiers"},"specifiers"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Property"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"property")),(0,i.kt)("td",{parentName:"tr",align:null},"Creates a property specifier.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Constant"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"constant")),(0,i.kt)("td",{parentName:"tr",align:null},"Evaluates to a ",(0,i.kt)("inlineCode",{parentName:"td"},"constant"),' object representing itself; models symbolic constants or AppleScript "enumerators".')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Command"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"command")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"basic-syntax#command-invocations"},"Invokes a command"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"parameter")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"basic-syntax#summarized-meta-terminology"},"Associates an argument with a parameter in a command invocation"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Variable"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"variable")),(0,i.kt)("td",{parentName:"tr",align:null},"Refers to stored data; usually defined using a ",(0,i.kt)("a",{parentName:"td",href:"data-flow#variables"},(0,i.kt)("inlineCode",{parentName:"a"},"let")," expression"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Resource"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"resource")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"resources#resource-terms"},"Refers to an imported resource"),".")))),(0,i.kt)("h2",{id:"term-uids"},"Term UIDs"),(0,i.kt)("p",null,"Every term has a ",(0,i.kt)("em",{parentName:"p"},"unique identifier")," (",(0,i.kt)("em",{parentName:"p"},"UID"),") which identifies its semantics at runtime. A UID is composed of a domain and a piece of data that uniquely identifies it within its domain. The set of allowable data values is determined by the domain."),(0,i.kt)("h3",{id:"uid-domains"},"UID domains"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Domain"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Data format"),(0,i.kt)("th",{parentName:"tr",align:null},"Example UIDs in this domain"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ae4")),(0,i.kt)("td",{parentName:"tr",align:null},"Four-byte AppleEvent code"),(0,i.kt)("td",{parentName:"tr",align:null},"4 MacRoman characters"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ae4:cwin"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ae8")),(0,i.kt)("td",{parentName:"tr",align:null},"AE event class code, AE event ID code"),(0,i.kt)("td",{parentName:"tr",align:null},"8 MacRoman characters"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ae8:coresetd"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ae12")),(0,i.kt)("td",{parentName:"tr",align:null},"AE event class code, AE event ID code, AE parameter code"),(0,i.kt)("td",{parentName:"tr",align:null},"12 MacRoman characters"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ae12:coresetddata"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"id")),(0,i.kt)("td",{parentName:"tr",align:null},"BushelScript native identifier (dervied from qualified term name)"),(0,i.kt)("td",{parentName:"tr",align:null},"Any number of term names separated by colons"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"id:variable name"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"id:Dictionary:type:identifier"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"res")),(0,i.kt)("td",{parentName:"tr",align:null},"Resource ID"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("code",null,"(system ","|","app","|","appid ","|","as):","<","data",">")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"res:system"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"res:app:System Preferences"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"res:appid:com.apple.Safari"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"res:as:/Users/user/Scripts/Script.scpt"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"asid")),(0,i.kt)("td",{parentName:"tr",align:null},"AppleScript user identifier"),(0,i.kt)("td",{parentName:"tr",align:null},"Any valid AppleScript user identifier"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"asid:an_applescript_handler"),(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"td"},"asid:AnAppleScriptHandler"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"var(plural)")),(0,i.kt)("td",{parentName:"tr",align:null},"Plural variant"),(0,i.kt)("td",{parentName:"tr",align:null},"Any UID"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"var(plural):ae4:cwin"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"\u2500\u2500\u2500\u2500"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2500\u2500\u2500\u2500\u2500\u2500\u2500"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2500\u2500\u2500\u2500\u2500\u2500"),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("h2",{id:"typed-uids-tuids"},"Typed UIDs (TUIDs)"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"typed UID")," (",(0,i.kt)("em",{parentName:"p"},"TUID"),") is the identifying combination of a term UID and a term type. A TUID unambiguously specifies a particular UID (and its particular semantics) in contexts where multiple types of terms might happen to share UIDs (but not semantics)."),(0,i.kt)("h2",{id:"overlapping-terms"},"Overlapping terms"),(0,i.kt)("p",null,"Two or more terms ",(0,i.kt)("em",{parentName:"p"},"overlap")," each other if they have the same name, TUID, or both."),(0,i.kt)("h3",{id:"synonyms"},"Synonyms"),(0,i.kt)("p",null,"Overlapping terms with the same TUID but different names are ",(0,i.kt)("em",{parentName:"p"},"synonyms")," of each other. Replacing a term with one of its synonyms yields no change in program behavior."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Examples"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"4 -- Can be any expression.\n\n(sqrt that) = (square root that) --\x3e true\n")),(0,i.kt)("p",null,"The result is always ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"sqrt")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"square root")," have identical semantics; they are synonyms."),(0,i.kt)("h3",{id:"homonyms"},"Homonyms"),(0,i.kt)("p",null,"Overlapping terms with identical names but different TUIDs are ",(0,i.kt)("em",{parentName:"p"},"homonyms")," of each other. Such identical-looking terms with different behavior are ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Principle_of_least_astonishment"},"surprising")," and should usually be avoided."),(0,i.kt)("p",null,"Note that homonyms are necessarily defined in different ",(0,i.kt)("a",{parentName:"p",href:"dictionaries"},"dictionaries"),", since a dictionary accessibly maps a name to at most one term."),(0,i.kt)("h3",{id:"identical-terms"},"Identical terms"),(0,i.kt)("p",null,"Terms that overlap in both name and TUID are called ",(0,i.kt)("em",{parentName:"p"},"identical terms"),". Identical terms can be used interchangeably like synonyms, but unlike homonyms they cause minimal confusion."),(0,i.kt)("p",null,"While identical terms have the same name and TUID, they are not guaranteed to contain the same dictionary."),(0,i.kt)("p",null,"Identical terms cannot be defined in the same dictionary, since such terms would simply coalesce into one."),(0,i.kt)("h2",{id:"raw-form"},"Raw form"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Raw form")," is special syntax that creates an anonymous term by specifying its type and UID inline. Terms created this way have the same syntactic function as any other term of their type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Syntax"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<raw-term> :: \xab <term-type> <term-uid> \xbb\n\n<term-type> ::\n  ( dictionary | type | property | constant | command | parameter |\n    variable | resource )\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Examples"),":"),(0,i.kt)("p",null,"ref \xabtype ae4:cwin\xbb --\x3e window\nref \xabtype var(plural):ae4:cwin\xbb --\x3e windows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'\nThis example refers to already-defined terms, which are displayed with their regular names at runtime.\n\n\n\xabresource res:appid:com.apple.Safari\xbb --\x3e application id "com.apple.Safari"\n')),(0,i.kt)("p",null,"If a resource's ",(0,i.kt)("a",{parentName:"p",href:"resources#requirements"},"requirement")," is not satisfied, a parse error will result as usual, although the error message may be less clear."),(0,i.kt)("p",null,"\xabtype ae4:abcd\xbb --\x3e \xabtype ae4:abcd\xbb"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\n`\xabtype ae4:abcd\xbb` is a not a defined term, but raw form can construct it on the fly. This is useful to quickly fill gaps in AppleScript terminology.\n")))}d.isMDXComponent=!0}}]);