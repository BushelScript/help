(self.webpackChunk=self.webpackChunk||[]).push([[614],{3905:(e,n,r)=>{"use strict";r.d(n,{Zo:()=>m,kt:()=>c});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var p=t.createContext({}),s=function(e){var n=t.useContext(p),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},m=function(e){var n=s(e.components);return t.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(r),c=i,f=u["".concat(p,".").concat(c)]||u[c]||d[c]||a;return r?t.createElement(f,o(o({ref:n},m),{},{components:r})):t.createElement(f,o({ref:n},m))}));function c(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=u;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<a;s++)o[s]=r[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}u.displayName="MDXCreateElement"},5438:(e,n,r)=>{"use strict";r.r(n),r.d(n,{frontMatter:()=>l,metadata:()=>p,toc:()=>s,default:()=>d});var t=r(2122),i=r(9756),a=(r(7294),r(3905)),o=["components"],l={title:"B: Grammar",sidebar_label:"B: Grammar"},p={unversionedId:"ref/grammar",id:"ref/grammar",isDocsHomePage:!1,title:"B: Grammar",description:"The following is an incomplete formal grammar for the bushelscripten language. The form is similar to BNF:",source:"@site/docs/ref/grammar.md",sourceDirName:"ref",slug:"/ref/grammar",permalink:"/help/docs/ref/grammar",version:"current",lastUpdatedBy:"Ian Gregory",lastUpdatedAt:1626226251,formattedLastUpdatedAt:"7/13/2021",sidebar_label:"B: Grammar",frontMatter:{title:"B: Grammar",sidebar_label:"B: Grammar"},sidebar:"ref",previous:{title:"A: Built-in Terms",permalink:"/help/docs/ref/built-in-terms"}},s=[{value:"Meta rules",id:"meta-rules",children:[]},{value:"Blank",id:"blank",children:[]},{value:"Sequence",id:"sequence",children:[]},{value:"Expression",id:"expression",children:[]},{value:"Definition",id:"definition",children:[]},{value:"Group",id:"group",children:[]},{value:"Literal",id:"literal",children:[]},{value:"Reference",id:"reference",children:[]},{value:"Get/set",id:"getset",children:[]},{value:"Control",id:"control",children:[]},{value:"Invocation",id:"invocation",children:[]},{value:"Compound",id:"compound",children:[]},{value:"Require",id:"require",children:[]},{value:"Specifier",id:"specifier",children:[]},{value:"Term",id:"term",children:[]},{value:"Term ID",id:"term-id",children:[]},{value:"Term name",id:"term-name",children:[]},{value:"Fundamental notions",id:"fundamental-notions",children:[]}],m={toc:s};function d(e){var n=e.components,r=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The following is an incomplete formal grammar for the ",(0,a.kt)("inlineCode",{parentName:"p"},"bushelscript_en")," language. The form is similar to ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form"},"BNF"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Anything inside ",(0,a.kt)("inlineCode",{parentName:"li"},"<")," and ",(0,a.kt)("inlineCode",{parentName:"li"},">"),' refers to a "rule" or "production", i.e., a named grammar element.'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"::")," denotes the definition of a rule."),(0,a.kt)("li",{parentName:"ul"},"Any non-[",(0,a.kt)("inlineCode",{parentName:"li"},"<")," ",(0,a.kt)("inlineCode",{parentName:"li"},">")," ",(0,a.kt)("inlineCode",{parentName:"li"},"(")," ",(0,a.kt)("inlineCode",{parentName:"li"},")")," ",(0,a.kt)("inlineCode",{parentName:"li"},"[")," ",(0,a.kt)("inlineCode",{parentName:"li"},"]")," ",(0,a.kt)("inlineCode",{parentName:"li"},"|")," ",(0,a.kt)("inlineCode",{parentName:"li"},"::")," whitespace] characters occur literally."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"(")," and ",(0,a.kt)("inlineCode",{parentName:"li"},")")," group elements."),(0,a.kt)("li",{parentName:"ul"},"Elements inside ",(0,a.kt)("inlineCode",{parentName:"li"},"[")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"]")," may or may not occur. Whether they occur can alter semantics."),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"|")," between two elements indicates that either may occur. Which one occurs can alter semantics.")),(0,a.kt)("p",null,"To simplify the grammar, we allow rules to be templates. We write rule ",(0,a.kt)("inlineCode",{parentName:"p"},"R")," templated on ",(0,a.kt)("inlineCode",{parentName:"p"},"X")," as ",(0,a.kt)("inlineCode",{parentName:"p"},"R( X )"),"."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<foo> :: foo [ <bar> ]\n<bar> :: bar ( baz | <bar> )\n")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Source code"),(0,a.kt)("th",{parentName:"tr",align:null},"Matches ",(0,a.kt)("inlineCode",{parentName:"th"},"<foo>"),"?"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"foo"),(0,a.kt)("td",{parentName:"tr",align:null},"\u2713")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"bar"),(0,a.kt)("td",{parentName:"tr",align:null},"\u2717")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"foo bar"),(0,a.kt)("td",{parentName:"tr",align:null},"\u2717")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"foo baz"),(0,a.kt)("td",{parentName:"tr",align:null},"\u2717")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"foo bar baz"),(0,a.kt)("td",{parentName:"tr",align:null},"\u2713")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"foo bar bar baz"),(0,a.kt)("td",{parentName:"tr",align:null},"\u2713")))),(0,a.kt)("p",null,"Some informal notions are defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"(parentheses)"),". Please note that this only a good approximation of the language syntax, ",(0,a.kt)("em",{parentName:"p"},"not")," a complete grammar. Devising one is not a goal at the moment."),(0,a.kt)("p",null,"The rules are organized more or less top-down."),(0,a.kt)("h2",{id:"meta-rules"},"Meta rules"),(0,a.kt)("p",null,"As a reminder, to simplify this grammar, we allow rules to be templates, writing rule ",(0,a.kt)("inlineCode",{parentName:"p"},"R")," templated on ",(0,a.kt)("inlineCode",{parentName:"p"},"X")," as ",(0,a.kt)("inlineCode",{parentName:"p"},"R( X )"),". Here are some generally applicable templates we'll use:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<pump>( R ) :: R [ <pump>( R ) ]\n<pump-with-end>( R, E ) <pump>( E | R )\n<delimited-list>( R, D ) :: R [ <pump>( D R ) ]\n<delimited-list-with-end>( R, D, E ) :: R ( E | <pump-with-end>( D R, E ) )\n")),(0,a.kt)("h2",{id:"blank"},"Blank"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"<blank>")," applies zero/one (depending on context) or more times between all syntax elements."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<blank> :: <space> | <block-comment>\n<block-comment> :: '--(' <utf-8>( ')--' )\n")),(0,a.kt)("h2",{id:"sequence"},"Sequence"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<program> :: [ <delimited-list>( <expression>, <sequence-delimiter> ) ]\n<sequence> :: <sequence>( end )\n<sequence>( E ) :: <delimited-list-with-end>( <expression>, <sequence-delimiter>, E )\n<sequence-delimiter> :: <pump>( <line-break> | <line-comment> )\n<line-comment> :: '--' <utf-8>( <line-break> )\n")),(0,a.kt)("h2",{id:"expression"},"Expression"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<expression> ::\n  <definition> |\n  <group> |\n  <literal> |\n  <reference> |\n  <get-set> |\n  <control> |\n  <invocation> |\n  <compound> |\n  <require> |\n  <specifier>\n")),(0,a.kt)("h2",{id:"definition"},"Definition"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<definition> ::\n  <term-definition> | <variable-definition> | <function-definition>\n<term-definition> ::\n  define <term-name> [ as ( <term> | <term-uri> ) ] |\n  defining <term-name> [ as ( <term> | <term-uri> ) ] <sequence>\n<variable-definition> :: let ( <term-name>( be ) <expression> | <term-name> )\n<function-defintion> ::\n  on <term-name>( <line-break> ) ( <delimited-list>( <parameter-spec>, <line-break> ) <line-break> do | do )\n  <sequence>\n<parameter-spec> ::\n  <term-name>( '(' ) '(' <term-name>( ')' ) [ ':' <expression> ] |\n  <term-name>( ':' ) <expression> |\n  <term-name>\n")),(0,a.kt)("h2",{id:"group"},"Group"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<group> ::\n  <grouped-expression> | <list> | <record>\n<grouped-expression> :: '(' <expression> ')'\n<list> :: '{' <delimited-list>( <expression>, ',' ) '}'\n<record> :: '{' <delimited-list>( <record-item>, ',' ) '}'\n<record-item> :: <expression> : <expression>\n")),(0,a.kt)("h2",{id:"literal"},"Literal"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<literal> ::\n  <integer> | <real> |\n  <string> | <multiline-string> | <interpreted-string> |\n  <boolean> | <missing> | <unspecified>\n<integer> :: <digits>(such that their value in base-10 is in [-2^63,2^63))\n<real> :: [ <digits> ] . <digits> [ ( e | E ) [ + | - ] <digits> ]\n<string> ::\n  ( ( \" <utf-8>( \" | <line-break> ) \" ) | ( \u201c <utf-8>( \u201d | <line-break> ) \u201d ) )\n<multiline-string> ::\n  ## <line-break> <utf-8>( ## ) |\n  ##(' <utf-8>( ')' ) <utf-8>( '##(' (same delimiter) ')' )\n<interpreted-string> :: #! <utf-8>( <line-break> ) <utf-8>( <interpreted-string> | #! )\n<boolean> :: true | false\n<missing> :: missing\n<unspecified> :: unspecified\n")),(0,a.kt)("h2",{id:"reference"},"Reference"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<reference> ::\n  <last-result> | <current-target> | <variable>\n<last-result> :: that\n<current-target> :: it\n")),(0,a.kt)("h2",{id:"getset"},"Get/set"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<get-set> ::\n  <get> | <ref> | <set>\n<get> :: get <expression>\n<ref> :: ref <expression>\n<set> :: set <expression> to <expression>\n")),(0,a.kt)("h2",{id:"control"},"Control"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<control> ::\n  <return> | <raise>\n<return> :: return <expression>\n<raise> :: raise <expression>\n")),(0,a.kt)("h2",{id:"invocation"},"Invocation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<invocation> ::\n  <command> [ <expression> ] [ <pump>( <parameter> <expression> ) ] |\n  <unary-prefix-operator> <expression> |\n  <expression> <binary-infix-operator> <expression>\n<unary-prefix-operator> ::\n  (one of the operators in the table at Part 2 \xa7 Unary Prefix Operators)\n<binary-infix-operator> ::\n  (one of the operators in the table at Part 2 \xa7 Binary Infix Operators)\n")),(0,a.kt)("h2",{id:"compound"},"Compound"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<compound> ::\n  <conditional> | <conditional-loop> | <bounded-loop> | <iterative-loop> |\n  <error-handler> |\n  <with-module> | <with-target> |\n  <anonymous-function>\n<conditional> ::\n  if <expression> (\n    then <expression> [ else ( <expression> | <sequence> ) ] |\n    [ then ] <sequence> |\n    [ then ] <sequence>( else ) ( <expression> | <sequence> )\n  )\n<conditional-loop> :: repeat while <expression> <sequence>\n<bounded-loop> :: repeat <expression> times <sequence>\n<iterative-loop> :: repeat for <term-name> in <expression> <sequence>\n<error-handler> ::\n  try ( <expression> handle | <sequence>( handle ) ) ( <expression> | <sequence> )\n<with-module> :: tell <expression> ( to <expression> | <sequence> )\n<with-target> :: target <expression> ( then <expression> | <sequence> )\n<anonymous-function> ::\n  ( take <pump-with-end>( <term-name>( ',' ), <term-name>( do ) ) | do ) <sequence>\n")),(0,a.kt)("h2",{id:"require"},"Require"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<require> ::\n  <require-library> | <require-system> | <require-app> | <require-applescript>\n<require-library> :: require library <term-name>\n<require-system> :: require system [ version ( v | V ) <digits> . <digits> [ . <digits> ] ]\n<require-app> :: require app [ id ] <term-name>\n<require-applescript> :: require AppleScript <term-name> at <string>\n")),(0,a.kt)("h2",{id:"specifier"},"Specifier"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<specifier> :: ( <element-specifier> | <property> ) [ of <expression> ]\n<element-specifier> ::\n  ( <simple-specifier> | <name-specifier> | <index-specifier> |\n    <id-specifier> |\n    <absolute-positioning-specifier> |\n    <relative-positioning-specifier> |\n    <all-specifier> |\n    <range-specifier> | <filter-specifier>\n  )\n<simple-specifier> :: <type> <expression>\n<name-specifier> :: <type> named <expression>\n<index-specifier> :: <type> index <expression>\n<id-specifier> :: <type> id <expression>\n<absolute-positioning-specifier> ::  first | middle | last | some ) <type>\n<relative-positioning-specifier> :: <type> ( before | after ) <expression>\n<all-specifier> :: ( all | every ) <type>\n<range-specifier> :: <type> <expression> ( thru | through ) <expression>\n<filter-specifier> :: <type> ( where | whose ) <expression>\n")),(0,a.kt)("h2",{id:"term"},"Term"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<raw-term> :: # <term-role> <term-uri>\n<term>( R ) :: <raw-term>(with role R) | (any term in the current lexicon with role R)\n<term> :: <term>(any role in <term-role>)\n<property> ::  <term>(property)\n<constant> ::  <term>(constant)\n<command> ::  <term>(command)\n<parameter> ::  <term>(parameter)\n<variable> ::  <term>(variable)\n<resource> ::  <term>(resource)\n")),(0,a.kt)("h2",{id:"term-id"},"Term ID"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<term-role> :: type | property | constant | command | parameter | variable | resource\n<term-uri>:: '[' (\n    id:<utf-8>( ']' ) |\n    res:(resource type):<utf-8>( ']' ) |\n    ae4:(4 characters) ']' | ae8:(8 characters) ']' | ae12:(12 characters) ']' |\n    asid:<utf-8>( ']' )\n  )\n")),(0,a.kt)("h2",{id:"term-name"},"Term name"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<term-name> :: delimited-list( <word>, <blank> )\n<term-name>( E ) :: <delimited-list-with-end>( <word>, <blank>, E )\n<lazy-term-name> :: <word> | ( '|' <term-name>( '|' ) )\n<word> :: <utf-8>( <space> | <category>( P*, S* NOT (one of _.-/'\u2019?) ) )\n")),(0,a.kt)("h2",{id:"fundamental-notions"},"Fundamental notions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<utf-8>( E ) :: (any UTF-8 string that does not match rule E) E\n<category>( X1, \u2026, Xn, [ NOT E ] ) ::\n  (any UTF-8 grapheme cluster in Unicode General Category X1, or \u2026, or Xn\n   that does not match rule E, if given)\n<space> :: <category>(Z* NOT <line-break>)\n<line-break> ::\n  (one of:\n    U+000D U+000A (CRLF), U+000A thru U+000D,\n    U+0085, U+2028, or U+2029\n  )\n<digits> :: (any sequence of decimal digits 0 thru 9)\n")))}d.isMDXComponent=!0}}]);